import { AppointmentRepository } from "@/domain/repositories/AppointmentRepository";
import { Appointment, AppointmentStatus } from "@/domain/entities/Appointment";
import { getSupabaseClient } from "@/lib/supabase/client";
import { TokenRepository } from "@/domain/repositories/TokenRepository";
import RepositoryFactory from "@/lib/repositories";

/**
 * Supabase appointment repository
 * Handles appointment operations using Supabase
 *
 * Backed by the `appointments` table with schema:
 * - doctor_id (references api.doctor_profile.id)
 * - patient_* fields (name, phone, age, gender)
 * - appointment_mode
 * - appointment_date, scheduled_time
 * - token_number, token_label
 * - status
 * - patient_notes, doctor_notes
 */
export class SupabaseAppointmentRepository implements AppointmentRepository {
  async createAppointment(
    appointment: Omit<Appointment, "id" | "createdAt" | "updatedAt">
  ): Promise<Appointment> {
    const supabase = getSupabaseClient();

    // Map domain status to DB status
    const dbStatus = this.mapDomainStatusToDb(appointment.status);
    console.log("ðŸš€ ~ SupabaseAppointmentRepository ~ createAppointment ~ dbStatus:", dbStatus)

    // Generate token number if not provided (backend generates it)
    // let tokenNumber = appointment.tokenNumber;
    // if (tokenNumber === 0 || tokenNumber == null) {
    //   // Get current token state and generate next token
    //   const tokenRepo: TokenRepository = RepositoryFactory.getTokenRepository();
    //   const tokenState = await tokenRepo.getCurrentToken(
    //     appointment.doctorId,
    //     appointment.clinicId
    //   );
    //   tokenNumber = tokenState.totalTokens + 1;
      
    //   // Increment total tokens count
    //   if (tokenRepo.incrementTotalTokens) {
    //     await tokenRepo.incrementTotalTokens(
    //       appointment.doctorId,
    //       appointment.clinicId
    //     );
    //   }
    // }

    // Build token label if not provided
    // const tokenLabel =
    //   appointment.tokenLabel || (tokenNumber != null
    //     ? `T-${tokenNumber}`
    //     : null);

    // Prepare insert data according to schema
    const insertData: any = {
      // Required fields
      doctor_id: appointment.doctorId,
      patient_name: appointment.patientName,
      patient_phone: appointment.patientPhone,
      appointment_mode: appointment.appointmentMode || "token",
      appointment_date: appointment.date,
      
      // Optional patient fields
      patient_age: appointment.patientAge ?? null,
      patient_gender: appointment.patientGender ?? null,
      
      // Time slot (null for token-based appointments)
      scheduled_time: null,
      
      // Token information (generated by backend)
      token_number: null,
      token_label: null,
      
      // Status (mapped from domain status)
      status: dbStatus,
      
      // Notes
      patient_notes: appointment.patientNotes ?? null,
      doctor_notes: appointment.doctorNotes ?? null,
      
      // User ID (null if guest, otherwise use the userId)
      user_id: appointment.userId && appointment.userId !== "guest" 
        ? appointment.userId 
        : null,
    };

    const { data, error } = await supabase
      .from("appointments")
      .insert(insertData)
      .select()
      .single();

    if (error) {
      throw new Error(error.message || "Failed to create appointment");
    }

    return this.mapToAppointment(data);
  }

  async getAppointmentById(id: string): Promise<Appointment | null> {
    const supabase = getSupabaseClient();
    const { data, error } = await supabase
      .from("appointments")
      .select("*")
      .eq("id", id)
      .single();

    if (error) {
      if ((error as any).code === "PGRST116") {
        return null; // Not found
      }
      throw new Error(error.message || "Failed to load appointment");
    }

    return data ? this.mapToAppointment(data) : null;
  }

  async getAppointmentsByUser(userId: string): Promise<Appointment[]> {
    const supabase = getSupabaseClient();

    // Look up user profile to get phone number
    const { data: profile, error: profileError } = await supabase
      .from("users")
      .select("id")
      .eq("id", userId)
      .single();

    if (profileError || !profile) {
      // If we can't resolve a phone number, we can't match appointments
      return [];
    }

    const { data, error } = await supabase
      .from("appointments")
      .select("*")
      .eq("user_id", profile.id)
      .order("created_at", { ascending: false });

    if (error) {
      throw new Error(error.message || "Failed to load appointments");
    }

    return (data || []);
  }

  async updateAppointmentStatus(
    id: string,
    status: AppointmentStatus
  ): Promise<Appointment> {
    const supabase = getSupabaseClient();
    const dbStatus = this.mapDomainStatusToDb(status);

    const { data, error } = await supabase
      .from("appointments")
      .update({
        status: dbStatus,
        updated_at: new Date().toISOString(),
      })
      .eq("id", id)
      .select()
      .single();

    if (error) {
      throw new Error(error.message || "Failed to update appointment");
    }

    return this.mapToAppointment(data);
  }

  async cancelAppointment(id: string): Promise<void> {
    await this.updateAppointmentStatus(id, AppointmentStatus.CANCELLED);
  }

  private mapDomainStatusToDb(status: AppointmentStatus): string {
    switch (status) {
      case AppointmentStatus.UPCOMING:
        return "booked";
      case AppointmentStatus.IN_PROGRESS:
        return "called";
      case AppointmentStatus.COMPLETED:
        return "completed";
      case AppointmentStatus.CANCELLED:
        return "cancelled";
      default:
        return "booked";
    }
  }

  private mapDbStatusToDomain(status: string): AppointmentStatus {
    switch (status) {
      case "booked":
      case "checked_in":
        return AppointmentStatus.UPCOMING;
      case "called":
        return AppointmentStatus.IN_PROGRESS;
      case "completed":
        return AppointmentStatus.COMPLETED;
      case "cancelled":
      case "no_show":
        return AppointmentStatus.CANCELLED;
      default:
        return AppointmentStatus.UPCOMING;
    }
  }

  private mapToAppointment(data: any): Appointment {
    return {
      id: data.id,
      // Map user_id from database, default to "guest" if null
      userId: data.user_id || "guest",
      doctorId: data.doctor_id,
      // Virtual clinic id for compatibility
      date: data.appointment_date,
      timeSlot: {
        startTime: data.scheduled_time || "",
        endTime: "",
      },
      tokenNumber: data.token_number ,
      status: this.mapDbStatusToDomain(data.status),
      patientName: data.patient_name,
      patientPhone: data.patient_phone,
      patientAge: data.patient_age ?? undefined,
      patientGender: data.patient_gender ?? undefined,
      appointmentMode: data.appointment_mode,
      tokenLabel: data.token_label ,
      patientNotes: data.patient_notes ?? undefined,
      doctorNotes: data.doctor_notes ?? undefined,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }
}
